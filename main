% MATLAB Script for Monocular Vision
% Connor Wolfe and Kristina Collins, EECS 499, Spring 2017

%% Section 1: Inputs
% This section inputs a .mp4 file for post-processing.
vidObj = VideoReader('ballvid.mp4');

while hasFrame(vidObj)
    video = readFrame(vidObj);
end
whos video

vidHeight = vidObj.Height;
vidWidth = vidObj.Width;

s = struct('cdata',zeros(vidHeight,vidWidth,3,'uint8'),...
    'colormap',[]);

vidObj.CurrentTime = 0.6;

k = 1;
while vidObj.CurrentTime <= .9% hasFrame(vidObj)
    s(k).cdata = readFrame(vidObj);
    k = k+1;
end

image(s(5).cdata)

%% Read STL
%TODO: Write section to accept dxf or stl or something for the object
conocube=stlread('Conocube.STL');

%% Turn on webcam: Demo code
webcamlist
cam=webcam('HP') %Turns on HP USB camera
preview(cam)
img=snapshot(cam);
imshow(img)
clear('cam') %Turns webcam off

%% Color segmentation
foo=im2bw(img, .1);
BW=edge(foo);
subplot(1, 2, 1), imshow(foo)
subplot(1, 2, 2), imshow(BW)


%% Camera calibration notes
 %open checkerboardPattern.pdf %opens the checkerboard pattern for
 %printing-printed by WEPA, 22mm to a side
 
 % Auto-generated by cameraCalibrator app on 24-Mar-2017
%-------------------------------------------------------


% Define images to process
imageFileNames = {'C:\Users\K\Documents\MATLAB\Image1.png',...
    'C:\Users\K\Documents\MATLAB\Image2.png',...
    'C:\Users\K\Documents\MATLAB\Image3.png',...
    'C:\Users\K\Documents\MATLAB\Image4.png',...
    'C:\Users\K\Documents\MATLAB\Image5.png',...
    'C:\Users\K\Documents\MATLAB\Image7.png',...
    };

% Detect checkerboards in images
[imagePoints, boardSize, imagesUsed] = detectCheckerboardPoints(imageFileNames);
imageFileNames = imageFileNames(imagesUsed);

% Generate world coordinates of the corners of the squares
squareSize = 22;  % in units of 'mm'
worldPoints = generateCheckerboardPoints(boardSize, squareSize);

% Calibrate the camera
[cameraParams, imagesUsed, estimationErrors] = estimateCameraParameters(imagePoints, worldPoints, ...
    'EstimateSkew', false, 'EstimateTangentialDistortion', false, ...
    'NumRadialDistortionCoefficients', 2, 'WorldUnits', 'mm');

% View reprojection errors
h1=figure; showReprojectionErrors(cameraParams, 'BarGraph');

% Visualize pattern locations
h2=figure; showExtrinsics(cameraParams, 'CameraCentric');

% Display parameter estimation errors
displayErrors(estimationErrors, cameraParams);

% For example, you can use the calibration data to remove effects of lens distortion.
originalImage = imread(imageFileNames{1});
undistortedImage = undistortImage(originalImage, cameraParams);

% See additional examples of how to use the calibration data.  At the prompt type:
% showdemo('MeasuringPlanarObjectsExample')
% showdemo('SparseReconstructionExample')

%% Webcam calibration parameters
load('webcamParams.mat'); %loads calibration data for HP webcam as the variable cameraParams

%% Section 2: Particle Filter
% This section will implement the particle filter that identifies which
% pixels belong to the object we're looking for. The entire section is in a
% while loop; at the end, another photo is taken. 

%% Initialization
% Particles are generated in a bounded volume
% The particles are converted to 2D, weighted, and resampled
% We generate X(t), X(t-1), and X(t-2) before beginning the particle filter
% proper.

%% Particle Filter:
t=t+1
%N=?
%% Motion model
% We generate a Gaussian noise term
for i=1:N
    %Begin with defining E(6x4x4) such that each Ei is the ith basis element of se(3).  Vals from Ikea paper 
    E=zeros(4,4,6)
    E(1,4,1)=1; E(2,4,2)=1; E(3,4,3)=1; E(2,3,4)=-1;E(3,2,4)=1; 
    E(1,3,5)=1; E(3,1,5)=-1; E(1,2,6)=-1; E(2,1,6)=-1;
    
    %Next, we define e=epsilon_i which is a gaussian with mean=0 and
    %covariance=Ew.  NOT SURE WHAT Ew IS!!??!?!  R = normrnd(mu,sigma)
    e= ;
    dW=sum(e*E);
    
    %Calculate X_t(i,:,:) from X_t1(i,:,:), A, and dW
    X_t(i,:,:)=X_t1(i,:,:)*exp(A(i,:,:) + dW*sqrt(1);
    
    %Calculate A from X_t1 and X_t2.  NEED PARAMATER a!!! Currently using
    %natural logarithm, but not sure if thats right.  
    A(i,:,:)=alog(X_t2(i,:,:)\X_t1(i,:,:));
end

%Optimize X via IRLS
for i=1:N
end

%% Measurement Model
% Here's where the computer vision happens. 
% From X*(t) and the image, we calculate the weight vector pi
% Each value of pi is the weight for the corresponding particle in X

% From image, find keypoints

% For loop: Convert each value in X* (3D) to a 2D expression, using MATLAB
% camera tools. Compare keypoints generated for each particle with the
% keypoints found in the image, and compute weights (pi) for each.

%% Resampling 
%NEED CONDITION TO CHECK IF NEED TO REINITIALIZE PARTICLES

%Get indices of which randomly selected X's we want to send to the next
%iteration based on weights pi
ind=1:N;
ind=randsample(ind, N, true, pi);

%Iterate X_t2 to X_t1 and X_t1 to X_t and A based on the indices found above
X_t2=X_t1;
X_t1=X_t(ind,:,:);
A=A(ind,:,:);

%END WHILE LOOP

% find position of object from a piecewise average of the particles in X
% Plot the keypoints of X on the image
